% HBIC_SELECTION Group similar biclusters and choose the best ones.
%   SEL_BICLUSTERS = HBIC_SELECTION(SELECTION_TYPE, BICLUSTERS, K_TRUE)
%
%   SELECTION_TYPE is an string variable indicating the type of model selection.
%   The available model selection types are:
%       'all'           - no selection, returns all biclusters in BICLUSTERS.
%       'top_b'         - Top K biclusters based on their HIV quality
%       'top_tree'      - Best K biclusters from the dendrogram
%       'merge_b'       - Best K new biclusters from merging similar ones in the dendrogram
%       'tree_auto'     - Find K* biclusters automatically from the dendrogram
%       'merge_auto'    - Creates K* new biclusters from merging similar ones in the dendrogram
%
%   BICLUSTERS is an structure with B biclusters generated by HBIC with 
%   the following properties:
%   	nbicluster,B     - the number of B candidate bicluster
%       RowxNum          - is NxB logical matrix with the row bicluster's positions
%       NumxCol          - is BxP logical matrix with the column bicluster's positions
%       Bic()            - an structure of size B with row and columns with 
%                           the positions of rows and columns, respectively.
%
%   K_TRUE is an integer representing the number of true biclusters. This
%   parameter is used for the selection types 'top_b', 'top_tree' and 'tree_auto'
%
%   SEL_BICLUSTERS is an structure with K (or K*) biclusters selected with
%   the following properties:
%   	nbicluster,K     - the number of K candidate bicluster
%       RowxNum          - is NxK logical matrix with the row bicluster's positions
%       NumxCol          - is KxP logical matrix with the column bicluster's positions
%       Bic()            - an structure of size K with row and columns with 
%                           the positions of rows and columns, respectively.
%
% -------------------------------------------------------------------------
%   Version 1.0 (Matlab R2020b Unix)
%   Copyright (c) 2023, A. Jose-Garcia (adan.jose-garcia@univ-lille.fr)
%   November 2023
% -------------------------------------------------------------------------
function [sel_biclusters] = hbic_selection(selection_type, biclusters, K_true)
%HBC Selection  of this function goes here
%   Detailed explanation goes here

% selection_type = {'all','top_b','tree_b','merge_b', 'tree_auto','merge_auto'}

simi_threshold = 0.2;
kb_found = biclusters.nbicluster;
if (nargin == 3 && (kb_found <= K_true)) || strcmpi(selection_type,'all')
    sel_biclusters = biclusters;
    return;
end

biclusters = bic_wfitness(biclusters); % (alpha * nquality) + ((1-alpha)*nsize)

if strcmpi(selection_type,'top_b')
    % max_nbics = floor(sqrt(max([nr nc])));
    sel_biclusters = selection_topb(biclusters,K_true);
    
% The number of bicluster is provided, KB_TRUE
elseif strcmpi(selection_type,'tree_b') || strcmpi(selection_type,'merge_b')
    % Computation of bicluster similarities
    DXX = bic_similarity(biclusters,'type2');
    Z = linkage(DXX,'ward');
    
    Clust = cluster(Z,'maxclust',K_true);
    if (K_true == 1)
        dendrogram(Z,0); xlabel('Biclusters'); 
    else
        leafOrder = optimalleaforder(Z,DXX);
        cutoff = median([Z(end-K_true+1,3) Z(end-K_true+2, 3)]);
        [H,~,Tidx] = dendrogram(Z,0,'colorthreshold',cutoff,'Reorder',leafOrder); xlabel('Biclusters'); 
    end
    if strcmpi(selection_type,'merge_b') 
        sel_biclusters = selection_merge(biclusters,Clust);     % MERGE biclusters
    else
        sel_biclusters = selection_bestfit(biclusters,Clust);   % SINGLE bicluster
    end
    
% The number of bicluster is determinated, KB_TRUE    
elseif strcmpi(selection_type,'tree_auto') || strcmpi(selection_type,'merge_auto')
    % Computation of bicluster similarities
    DXX = bic_similarity(biclusters,'type2');
    Z = linkage(DXX,'ward');
    
    if (kb_found == 2) && DXX(1,2) <= simi_threshold % parameter of similarity level (80%)
        kb_automatic = 1;
        dendrogram(Z,0); xlabel('Biclusters'); 
    else
        dist_links = diff(Z(:,3));
        fdist_links = flip(dist_links);
        [~,idxk] = max(fdist_links);
        kb_automatic = idxk + 1;
        
        leafOrder = optimalleaforder(Z,DXX);
        cutoff = median([Z(end-kb_automatic+1,3) Z(end-kb_automatic+2, 3)]);
        [H,~,Tidx] = dendrogram(Z,0,'colorthreshold',cutoff,'Reorder',leafOrder); xlabel('Biclusters'); 
    end
    
    Clust = cluster(Z,'maxclust',kb_automatic);
    if strcmpi(selection_type,'merge_auto') 
        sel_biclusters = selection_merge(biclusters,Clust);     % MERGE biclusters
    else
        sel_biclusters = selection_bestfit(biclusters,Clust);   % SINGLE bicluster
    end
else
    disp('Unrecognized Selection Type');

end
end

function [biclusters_selected] = selection_topb(biclusters, max_nbics)
%BIC 

[~,sidx] = sort(biclusters.quality);

biclusters_selected.nbicluster = max_nbics;
RowxNum = []; NumxCol = []; quality = [];
for ibic=1:biclusters_selected.nbicluster
    
    idx = sidx(ibic);
    
    rows = biclusters.Bic(idx).rows;
    cols = biclusters.Bic(idx).cols;
    
    RowxNum_i = biclusters.RowxNum(:,idx);
    NumxCol_i = biclusters.NumxCol(idx,:);

    biclusters_selected.Bic(ibic) = struct('rows',rows,'cols',cols);
    RowxNum = [RowxNum RowxNum_i];
    NumxCol = [NumxCol; NumxCol_i];
    quality = [quality biclusters.quality(idx)];
end
biclusters_selected.RowxNum = logical(RowxNum);
biclusters_selected.NumxCol = logical(NumxCol);
biclusters_selected.quality = quality;
end


function [biclusters_selected] = selection_bestfit(biclusters, clust)
%BIC 
%   

ulabels = unique(clust);

biclusters_selected.nbicluster = numel(ulabels);
RowxNum = []; NumxCol = []; quality = [];
for ibic=1:biclusters_selected.nbicluster
    
    id = find(clust==ulabels(ibic));
    [v,tidx] = min(biclusters.fitness(id));
    idx = id(tidx(1)); % tidx might return more than one value: tidx(1)
    
    rows = biclusters.Bic(idx).rows;
    cols = biclusters.Bic(idx).cols;
    
    RowxNum_m = biclusters.RowxNum(:,idx);
    NumxCol_m = biclusters.NumxCol(idx,:);
    biclusters_selected.Bic(ibic) = struct('rows',rows,'cols',cols);
    RowxNum = [RowxNum RowxNum_m];
    NumxCol = [NumxCol; NumxCol_m];
    quality = [quality biclusters.quality(idx)];
end
biclusters_selected.RowxNum = logical(RowxNum);
biclusters_selected.NumxCol = logical(NumxCol);
biclusters_selected.quality = quality;
end


function [biclusters_merged] = selection_merge(biclusters, clust)
%BIC MERGING it merges biclusters as indicated in CLUST
%   

ulabels = unique(clust);

biclusters_merged.nbicluster = numel(ulabels);
RowxNum = []; NumxCol = [];
for ibic=1:biclusters_merged.nbicluster
    
    idx = find(clust==ulabels(ibic));
    rows = biclusters.Bic(idx(1)).rows;
    cols = biclusters.Bic(idx(1)).cols;
    RowxNum_m = biclusters.RowxNum(:,idx(1));
    NumxCol_m = biclusters.NumxCol(idx(1),:);
    for j=2:numel(idx)
        rows = union(rows, biclusters.Bic(idx(j)).rows);
        cols = union(cols, biclusters.Bic(idx(j)).cols);
        RowxNum_m = or(RowxNum_m,biclusters.RowxNum(:,idx(j)));
        NumxCol_m = or(NumxCol_m,biclusters.NumxCol(idx(j),:));
    end
    biclusters_merged.Bic(ibic) = struct('rows',rows,'cols',cols);
    RowxNum = [RowxNum RowxNum_m];
    NumxCol = [NumxCol; NumxCol_m];
end
biclusters_merged.RowxNum = logical(RowxNum);
biclusters_merged.NumxCol = logical(NumxCol);
end

function [biclusters,fit,nquality,nsizemax] = bic_wfitness(biclusters,alpha)
%   Detailed explanation goes here

if nargin == 1
    alpha = 0.5;
end
nquality =  normalize(biclusters.quality,'range');  % minimization

nsizemax =  normalize(biclusters.sizeRxC,'range');     % maximinarion
nsize = 1 - nsizemax;                                  % minimization


fit = (alpha * nquality) + ((1-alpha)*nsize);

biclusters.fitness = fit;
end

